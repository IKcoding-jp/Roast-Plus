---
alwaysApply: true
---

# Firebase

## Firestore の原則

### Single Source of Truth
- Firestore が Single Source of Truth であること
- 画面表示・状態・履歴のいずれも、Firestore の値を優先する
- ローカル状態は一時キャッシュであり、最終決定権を持たない

### データフロー
- 購読（`onSnapshot`）は UI データの唯一のフローとする
- 「Firestore 更新 → リスナー発火 → ローカル状態更新 → UI 更新」の流れを徹底する
- ローカル状態が Firestore からの最新値を上書きする実装・提案は禁止

### 書き込みの原則
- Firestore 書き込みは「1回の確定書き込み」で完結させる
- `setTimeout` や段階的な後書き込みなど、途中で unmount/エラーが起きると永続化されない可能性がある設計は避ける
- 1回のユーザー操作ごとに、Firestore には「最終状態（結果＋ターゲット日＋履歴＋イベント）」まで反映する
- 複数の書き込みが必要な場合は、Firestore のトランザクション（`runTransaction`）を使用する

## パス構造

### ユーザーデータ
- `/users/{userId}`: 各ユーザーのデータ（`AppData` 型）
- Firestoreセキュリティルールで、ユーザーは自分のデータのみアクセス可能

### マスターデータ
- `/defectBeans`: 全ユーザー共通の欠点豆マスターデータ
- 全ユーザーが読み取り可能

## マルチデバイス同期

### リアルタイム同期
- Firestoreの`onSnapshot`により、全デバイス間でデータがリアルタイムに同期
- 9台のデバイスが同時に接続することを考慮し、不要なリスナーを避ける

### 書き込み最適化
- **書き込みキュー**: 書き込みリクエストをキューに追加し、順次処理
- **デバウンス**: 300ms のデバウンスにより、連続する書き込みをまとめる
- **セマフォ制御**: 最大同時実行数3により、Write stream exhaustedエラーを防止
- 9台のデバイスからの同時アクセスに対応

### 競合の回避
- 多端末からの同時更新がありうる箇所では、Firestore のトランザクション（`runTransaction`）を検討
- サーバータイムスタンプ（`serverTimestamp()`）を使用して、更新時刻の整合性を保つ
- 日付や状態の判定に、端末のローカル時計を使わない

### デバイス識別
- `RoastTimerState` の `triggeredByDeviceId`、`completedByDeviceId` など、デバイス識別子を使用してマルチデバイス同期を実現

## トランザクション推奨パターン

### 同時更新が発生する可能性がある場合
- 複数のフィールドを同時に更新する必要がある場合
- カウンターや集計値の更新
- 状態遷移の整合性を保つ必要がある場合

### トランザクションの使用例
```typescript
await runTransaction(db, async (transaction) => {
  const docRef = doc(db, 'users', userId);
  const docSnap = await transaction.get(docRef);
  if (!docSnap.exists()) {
    throw new Error('Document does not exist!');
  }
  const currentData = docSnap.data();
  transaction.update(docRef, {
    ...currentData,
    updatedAt: serverTimestamp(),
  });
});
```

## PWA + オフライン時の Firestore/キャッシュの扱い

### オフライン対応
- Service Workerにより、オフライン時も基本的な機能が利用可能
- Firestoreのオフラインキャッシュを活用
- ネットワーク接続が不安定な環境でも動作

### オフライン時の動作
- Firestore のオフラインキャッシュからデータを読み取る
- 書き込みはオフラインキューに保存され、ネットワーク接続が復旧した際に自動的に同期される
- オフライン時の書き込みも、整合性を保つためにトランザクションを使用することを検討

### キャッシュ戦略
- リアルタイムリスナーは適切にクリーンアップ（`Unsubscribe`を返す）
- 不要なリスナーは解除してメモリリークを防止

## Firebase Storage

### 画像アップロード
- Firebase Storage を使用して画像をアップロード
- パス: `defect-beans/{userId}/{defectBeanId}`
- Storageルールで画像アップロードを制限
- 認証済みユーザーのみが自分の画像をアップロード可能

### Storage操作
- Storage操作は `lib/storage.ts` で管理
- エラーハンドリングを適切に実装

## エラーハンドリング

### Firestore操作
- Firestore操作のエラーは適切にキャッチし、ログに記録
- エラー時はデフォルトデータを返すか、ユーザーに通知
- 書き込みエラー時はリトライ機構を実装（最大3回、指数バックオフ）

### データ検証
- データ読み込み時の型チェックを実施
- 存在しないデータの場合はデフォルトデータを返す

## セキュリティ

### Firestoreルール
- `firestore.rules` でユーザーごとのデータアクセスを制限
- 認証済みユーザーのみが自分のデータにアクセス可能
- 欠点豆マスターデータは全ユーザーが読み取り可能

### Storageルール
- `storage.rules` で画像アップロードを制限
- 認証済みユーザーのみが自分の画像をアップロード可能

### 環境変数
- Firebase設定は環境変数で管理（`.env.local`に配置）
- `NEXT_PUBLIC_` プレフィックスはクライアント側で公開されるため注意
