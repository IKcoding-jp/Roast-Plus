---
alwaysApply: true
---

# RoastPlus プロジェクト専用 AI ルール

## 最重要原則：Multi-Device + Firestore Consistency（整合性）

このプロジェクトにおける AI の最優先ポリシーです。**すべてのコード変更・提案は、この原則に従ってください。**

### 1. Firestore が Single Source of Truth であること

- 画面表示・状態・履歴のいずれも、Firestore の値を優先する。
- ローカル状態は一時キャッシュであり、最終決定権を持たない。
- Firestore の値とローカル状態が矛盾する場合は、常に Firestore の値を正とする。

### 2. 複数デバイス間で「同じタイミングに同じデータ」が見えることを最優先する

- 日付や状態の判定に、端末のローカル時計を使わない。
- 可能な限り、Firestore に保存された日付・状態・値、もしくはサーバータイムスタンプ（`serverTimestamp()`）を基準にする。
- ローカル時間に依存する実装は、マルチデバイス間で不整合を引き起こすため禁止。

### 3. Firestore 書き込みは「1回の確定書き込み」で完結させる

- `setTimeout` や段階的な後書き込みなど、途中で unmount/エラーが起きると永続化されない可能性がある設計は避ける。
- 1回のユーザー操作ごとに、Firestore には「最終状態（結果＋ターゲット日＋履歴＋イベント）」まで反映する。
- 複数の書き込みが必要な場合は、Firestore のトランザクション（`runTransaction`）を使用する。

### 4. 購読（onSnapshot）は UI データの唯一のフローとする

- 「Firestore 更新 → リスナー発火 → ローカル状態更新 → UI 更新」の流れを徹底する。
- ローカル状態が Firestore からの最新値を上書きする実装・提案は禁止。
- 楽観的更新（Firestore 更新前に UI だけ先に進める）は、このプロジェクトでは禁止。

### 5. Firestore のデータ構造を変更する場合は必ず、変更前に説明する

- 既存データへの影響を文章で説明する。
- マイグレーション方針を文章で説明する。
- 説明の後に、コードの提案・変更を行う。

### 6. 多端末からの同時更新がありうる箇所では、競合対策を検討する

- 競合が起こる可能性を評価する。
- 必要に応じて Firestore のトランザクション（`runTransaction`）利用を優先的に検討する。
- サーバータイムスタンプを使用して、更新時刻の整合性を保つ。

### 7. UI/UX（アニメーションなど）と整合性が衝突する場合

- 常に「整合性 ＞ UX」という優先順位で設計・修正案を提示する。
- 整合性を損なう UX 改善は提案しない。

---

## AI の行動手順（推論フロー）

コード変更・提案を行う際は、以下の標準フローに従ってください。

### ステップ 1: タスクの分類と影響範囲の特定

タスクを受け取ったら、まず以下を実行：

1. **目的の分類**
   - バグ修正 / 新機能追加 / リファクタ / その他

2. **整合性への影響推定**
   - Firestore / マルチデバイス整合性に影響しそうかを推定
   - 影響する場合は、どのようなリスクがあるかを箇条書きで整理

3. **影響範囲の特定**
   - `lib/firestore.ts`、`hooks/useAppData.ts`、コンポーネントなど、変更が必要なファイルを特定

### ステップ 2: 現状分析と改善方針の説明

コード変更前に、以下を文章で説明：

- **現状の挙動を要約**
  - 該当コード周辺の意図をコメントや型から読み取り、現状の挙動を要約する

- **整合性リスクの有無**
  - ローカル時間依存 / 段階書き込み / 競合 / 楽観的更新 などのリスクを箇条書きで整理

- **改善方針（理想のデータフロー）**
  - どのように Firestore を Single Source of Truth として扱うか
  - マルチデバイス間で整合性を保つ方法

### ステップ 3: コード変更と説明

コード変更後は、以下を明示：

- **diff を提示**
  - 変更内容を明確に示す

- **解決したリスクの明示**
  - 「どのリスク（ローカル時間 / 段階書き込み / 競合 etc.）を解消したか」を明示する

---

## 禁止事項リスト

以下の実装パターンは、マルチデバイス整合性を損なうため**禁止**です。

### ❌ Firestore の値をローカル状態が上書きする構造の提案

```typescript
// 禁止例
const [localData, setLocalData] = useState(data);
// Firestore 更新前に localData を変更して UI を更新
setLocalData(newData);
await updateFirestore(newData); // 後から Firestore を更新
```

### ❌ 日付ロジックを端末ローカル時間に依存させる提案

```typescript
// 禁止例
const today = new Date(); // ローカル時間を使用
const isToday = someDate.toDateString() === today.toDateString();
```

**正しい例**: Firestore のサーバータイムスタンプまたは Firestore に保存された日付を使用

### ❌ setTimeout/段階書き込み/後から永続化など、不確実な Firestore 書き込み

```typescript
// 禁止例
setTimeout(async () => {
  await updateFirestore(data); // 途中で unmount されると永続化されない
}, 1000);
```

**正しい例**: 1回の操作で Firestore に最終状態を書き込む、またはトランザクションを使用

### ❌ 1回のユーザー操作に対して、明確な理由なく複数回 Firestore に書き込む提案

```typescript
// 禁止例（明確な理由がない場合）
await updateField1(data1);
await updateField2(data2);
await updateField3(data3);
```

**正しい例**: トランザクションで一括更新、または1回の書き込みで全フィールドを更新

### ❌ Firestore のフィールド削除・データモデル破壊を、ユーザー確認なしに提案

- データ構造の変更は、必ず既存データへの影響とマイグレーション方針を説明してから提案する

### ❌ 「Firestore 更新前に UI だけ先に進める」ような楽観的更新の導入提案

```typescript
// 禁止例（このプロジェクトでは）
setLocalState(newState); // UI を先に更新
await updateFirestore(newState); // 後から Firestore を更新
```

**正しい例**: Firestore 更新 → onSnapshot 発火 → UI 更新の順序を守る

---

## タスク別の対応方針

### バグ修正依頼のとき

1. **再現条件と影響範囲の推定**
   - 「再現条件」と「影響範囲」を文章で整理する
   - どのレイヤーの問題かを切り分ける：
     - UI / 状態管理
     - Firestore 書き込み
     - Firestore 購読 / リスナー
     - PWA / オフラインキャッシュ

2. **整合性リスクの評価**
   - マルチデバイス / オフライン / PWA 周りの不具合リスクを箇条書きで整理

3. **修正案の提示**
   - 可能なら「最小修正」と「理想設計」の2案を提示し、どちらで進めるかを提案する
   - 整合性を保つための修正方針を説明する

4. **修正の実施**
   - 変更方針を文章で説明したあとに、コードを書き換える
   - 最後に diff を示し、「どの問題を解決する変更か」を明示する

### 新機能追加のとき

1. **データモデルとの整合性確認**
   - 既存のデータモデル（`AppData` など）との整合性を最優先する
   - 必要に応じて、データ構造の変更案とマイグレーション方針を説明する

2. **実装順序**
   - 型定義 → Firestore 関数 → hook → UI の順に実装する
   - `lib/firestore.ts` に追加関数を定義し、それを hooks / components から利用する形に揃える

3. **マルチデバイス対応の確認**
   - 新機能は複数デバイス間での動作を確認する
   - 必要に応じて、トランザクションやサーバータイムスタンプを使用する

### リファクタ依頼のとき

1. **リファクタのゴールを明確化**
   - 「リファクタのゴール（可読性 / 責務分割 / 再利用）」を文章で整理する
   - 挙動を変えないリファクタか、仕様変更を含むかを明示する

2. **影響範囲の限定**
   - 1回のリファクタで触るファイルは、関連性の高いものに限定する
   - 大規模リファクタやディレクトリ構造の変更は、ユーザーから明示的な依頼がある場合のみ行う

3. **整合性の維持**
   - `lib/firestore.ts` の関数インターフェースを維持（既存コードとの互換性）
   - データ操作の不変性を保つ

---

## 詳細仕様ドキュメント

以下の詳細仕様は、`.cursor/rules.d/` 配下のファイルを参照してください。

- **アーキテクチャ**: `.cursor/rules.d/architecture.md`
  - プロジェクト概要、技術スタック、ディレクトリ構造、アーキテクチャレベルの制約

- **データモデル**: `.cursor/rules.d/data-model.md`
  - `AppData` 型の概要、各型の役割、データ操作の原則

- **Firebase**: `.cursor/rules.d/firebase.md`
  - Firestore/Storage の原則、マルチデバイス同期、書き込み最適化、トランザクション

- **機能**: `.cursor/rules.d/features.md`
  - 各機能の概要、マルチデバイス整合性のポイント

- **ビルド・デプロイ**: `.cursor/rules.d/build-deploy.md`
  - 静的エクスポート、Firebase Hosting、キャッシュ戦略、PWA 挙動

---

## コーディング規約

### TypeScript
- 型定義は `types/index.ts` に集約
- 既存の型定義を尊重し、一貫性を保つ
- `any` の使用を避け、適切な型を定義

### React/Next.js
- Server Componentsを優先し、必要に応じてClient Componentsを使用
- カスタムフックでロジックを分離
- コンポーネントは小さく、単一責任の原則に従う
- ページコンポーネントは `app/` ディレクトリに配置

### スタイリング
- Tailwind CSS 4を使用
- インラインクラスでスタイルを記述
- **レスポンシブデザイン**: iPadとスマートフォンの両方で快適に使用できるよう、画面サイズに応じたレイアウトを実装
- **タッチ操作最適化**: ボタンやインタラクティブ要素は、タッチ操作に適したサイズ（最小44x44px）を確保

### Firebase操作
- Firestore操作は `lib/firestore.ts` に集約
- Firebase設定は `lib/firebase.ts` で管理
- 認証関連は `lib/auth.ts` で管理
- Storage操作は `lib/storage.ts` で管理
- エラーハンドリングを適切に実装
- リアルタイム更新には `onSnapshot` を使用
- **マルチデバイス同期**: 複数デバイス間でのデータ競合を避けるため、Firestoreのトランザクションやサーバータイムスタンプを活用
- **書き込み最適化**: 書き込みキュー、デバウンス（300ms）、セマフォ制御（最大同時実行数3）により、9台のデバイスからの同時アクセスに対応

---

## エラーハンドリング

### Firebase操作
- Firestore操作のエラーは適切にキャッチし、ログに記録
- エラー時はデフォルトデータを返すか、ユーザーに通知
- 書き込みエラー時はリトライ機構を実装（最大3回、指数バックオフ）

### データ検証
- データ読み込み時の型チェックを実施
- 存在しないデータの場合はデフォルトデータを返す

---

## パフォーマンス

### Firestore
- リアルタイムリスナーは適切にクリーンアップ（`Unsubscribe`を返す）
- 不要なリスナーは解除してメモリリークを防止
- **マルチデバイス最適化**: 9台のデバイスが同時に接続することを考慮し、不要なリスナーを避ける
- **書き込み最適化**: 書き込みキュー、デバウンス（300ms）、セマフォ制御（最大同時実行数3）により、Write stream exhaustedエラーを防止
- **オフライン対応**: Service Workerにより、ネットワーク接続が不安定な環境でも動作

### React
- 不要な再レンダリングを避ける
- カスタムフックで状態管理を最適化
- `useMemo`、`useCallback`を適切に使用
- **モバイルパフォーマンス**: スマートフォンのリソース制約を考慮し、軽量な実装を心がける

### PWA機能
- Service Workerは本番環境でのみ有効化（`process.env.NODE_ENV === 'production'`）
- Web App Manifest（`site.webmanifest`）でPWA設定を管理
- オフライン時の動作を考慮した実装

---

## セキュリティ

### 環境変数
- Firebase設定は環境変数で管理（`.env.local`に配置）
- `NEXT_PUBLIC_` プレフィックスはクライアント側で公開されるため注意

### Firestoreルール
- `firestore.rules` でユーザーごとのデータアクセスを制限
- 認証済みユーザーのみが自分のデータにアクセス可能
- 欠点豆マスターデータは全ユーザーが読み取り可能

### Storageルール
- `storage.rules` で画像アップロードを制限
- 認証済みユーザーのみが自分の画像をアップロード可能
